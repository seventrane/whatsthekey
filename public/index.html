<!DOCTYPE html>
<html>
<head>
  <title>What's The Key?'</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link rel="stylesheet" href="/stylesheets/style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/4.0.0/mdb.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <style>
    .progressMessage {
      font-family: monospace;
      color: #333;
      white-space: pre-wrap;
    }
    .step {
      color: #4caf50; /* green */
    }
    .info {
      color: #03a9f4; /* blue */
    }
    .success {
      color: #4caf50; /* green */
    }
    .warning {
      color: #ffc107; /* amber */
    }
    .error {
      color: #f44336; /* red */
    }
  </style>
</head>
<body>
  <h1 class="text-center" id="todo">Find Key of Audio File:</h1>
  <section style="background-color:rgb(4 0 255 / 6%);">
    <div class="container-lg p-5">
      <div class="row d-flex justify-content-center align-items-center">
        <div class="col col-xl-10">
          <div class="card">
            <div class="card-body p-5 flex-colx">
              <input type="file" id="audioFileInput" accept="audio/*">
              <button class="upload_btn" onclick="uploadAudio()">Upload</button>
              <div id="progressMessage" class="progressMessage"></div> <!-- Add a div to display progress messages -->
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  
  <section style="background-color:rgb(4 0 255 / 6%);">
    <div class="container-lg p-5">
      <div class="row d-flex justify-content-center align-items-center">
        <div class="col col-xl-10">
          <div class="card">
            <div class="card-body p-5 flex-colx">
			  <form id="uploadForm" action="/api/uploadFolder" method="POST" enctype="multipart/form-data">
		    	  <input type="file" name="folderPath" id="folderPath" webkitdirectory directory multiple>
		    	  <button type="submit">Upload Folder</button>
		  	  </form>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>
  
  <section>
	  
  </section>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/4.0.0/mdb.min.js"></script>
  <script src="../js/client.js"></script>

  <script>
  	  const folderPath = "./uploads";
  	        const urlIP= "173.68.138.70";
  	        const urlPort = "3000";

			
			// Define a fake https object for client-side use
			const https = {
			  Agent: class {
			    constructor(options) {
			      this.rejectUnauthorized = options.rejectUnauthorized !== undefined ? options.rejectUnauthorized : true;
			    }
			    // Define a default checkServerIdentity method
			    static defaultCheckServerIdentity(host, cert) {
			      return require('tls').checkServerIdentity(host, cert);
			    }
			  }
			};

			async function uploadAudio() {
			  const fileInput = document.getElementById('audioFileInput');
			  const file = fileInput.files[0];

			  if (!file) {
			    console.error('No file selected');
			    return;
			  }

			  const formData = new FormData();
			  formData.append('audioFile', file);

			  document.getElementById('progressMessage').innerHTML = '<span class="step">Starting key signature detection...</span><br>'; // Display progress message

			  // Custom agent to handle certificate validation
			  const customAgent = new https.Agent({
			    rejectUnauthorized: true, // Set to true to reject all untrusted certificates by default
			    checkServerIdentity: function (host, cert) {
			      // Check if the certificate is self-signed
			      const isSelfSigned = cert.subject.CN === cert.issuer.CN;

			      if (isSelfSigned) {
			        // If the certificate is self-signed, allow it
			        console.log('Self-signed certificate detected. Skipping validation.');
			        return undefined; // Return undefined to bypass validation
			      } else {
			        // If the certificate is not self-signed, perform default validation
			        return https.Agent.defaultCheckServerIdentity(host, cert);
			      }
			    }
			  });

			  // Modify fetch request options to use custom agent
			  const requestOptions = {
			    method: 'POST',
			    body: formData,
			    agent: customAgent // Use the custom agent for this request
			  };

			  console.log('Sending request:', requestOptions);

			  fetch(`https://${encodeURIComponent(urlIP)}:${encodeURIComponent(urlPort)}/api/uploadFile`, requestOptions)
			    .then(response => {
			      console.log('Response received:', response);
			      if (!response.ok) {
			        throw new Error('Failed to upload file');
			      }
			      return response.json();
			    })
			    .then(data => {
			      console.log('Upload success:', data.result);
			      document.getElementById('progressMessage').innerHTML += '<span class="step">Uploaded successfully...</span> <br>'; // Display progress message
			      document.getElementById('progressMessage').innerHTML += '<span class="step">Preparing audio data...</span><br>'; // Display progress message
			      fetchKeys();  
			    })
			    .catch(error => {
			      console.error('Upload failed:', error);
			      // Log the response if available
			      if (error.response) {
			        console.error('Response:', error.response);
			      }
			      document.getElementById('progressMessage').innerHTML = '<span class="error">Upload failed. Please try again.</span>'; // Display error message
			    });
			}
			
		  
  // Get the form element
  const form = document.getElementById('uploadForm');

  // Add a submit event listener to the form
  form.addEventListener('submit', async (event) => {
    event.preventDefault(); // Prevent the default form submission

	// Get the selected folder path
	const folderPath = document.getElementById('folderPath').files;

	// Create a FormData object to send data in multipart/form-data format
	const formData = new FormData();

	// Iterate over each file in the selected folder
	for (let i = 0; i < folderPath.length; i++) {
	  // Append each file to the FormData object with the same key
	  formData.append('audioFiles', folderPath[i]);
	}
    
    // Log the FormData object to the console
    console.log($(formData));
	
//	uploadLocally();
	

    // Send the POST request using fetch
    try {
      const response = await fetch(`https://${encodeURIComponent(urlIP)}:${encodeURIComponent(urlPort)}/api/upload`, {
        method: 'POST',
        body: formData
      });

      // Check if the request was successful
      if (!response.ok) {
        throw new Error('Failed to upload folder');
      }

      // Parse the JSON response
      const data = await response.json();
      console.log(data); // Do something with the response data
    } catch (error) {
      console.error(error);
    }
	


  });
  
  function fetchKeys() {
      const folderPath = "./uploads";
      const urlIP= "173.68.138.70";
      const urlPort = "3000";
	  
      document.getElementById('progressMessage').innerHTML += '<span class="success">Audio data prepared successfully.</span><br>'; // Display progress message
      document.getElementById('progressMessage').innerHTML += '<span class="step">Running key signature detection...</span><br>'; // Display progress message

      fetch(`https://${encodeURIComponent(urlIP)}:${encodeURIComponent(urlPort)}/api/myFunction?folderPath=${encodeURIComponent(folderPath)}`)
          .then(response => {
              if (!response.ok) {
                  throw new Error('Network response was not ok');
              }
              return response.json();
          })
          .then(response => {
              // Check if 'result' property exists and is an array
              if (!response.result || !Array.isArray(response.result)) {
                  console.error('Result is not an array:', response.result);
                  return; // Exit early if 'result' is not an array
              }

              // Access the 'result' array
              const data = response.result;

              // Assuming data is an array of arrays with [path, key] structure
              data.forEach(innerArray => {
                  if (!Array.isArray(innerArray)) {
                      console.error('Inner array is not iterable:', innerArray);
                      return; // Exit early if 'innerArray' is not an array
                  }

                  const [path, key] = innerArray; // Destructuring assignment to extract path and key
                  document.getElementById('progressMessage').innerHTML += `<span class="success">Key signature detected.</span><br><span class="info">Key signature:</span> ${key}<br>`; // Display progress message
              });

              document.getElementById('progressMessage').innerHTML += '<span class="success">Key signatures fetched successfully.</span>'; // Display success message
          })
          .catch(error => {
              console.error('Failed to fetch key signatures:', error);
              document.getElementById('progressMessage').innerHTML = '<span class="error">Failed to fetch key signatures. Please try again.</span>'; // Display error message
          });
  }
  
	
  </script>
</body>
</html>
